static const char* satClipKernelsCL= \
"\n"
"#pragma OPENCL EXTENSION cl_amd_printf : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable\n"
"\n"
"#ifdef cl_ext_atomic_counters_32\n"
"#pragma OPENCL EXTENSION cl_ext_atomic_counters_32 : enable\n"
"#else\n"
"#define counter32_t volatile global int*\n"
"#endif\n"
"\n"
"#define GET_GROUP_IDX get_group_id(0)\n"
"#define GET_LOCAL_IDX get_local_id(0)\n"
"#define GET_GLOBAL_IDX get_global_id(0)\n"
"#define GET_GROUP_SIZE get_local_size(0)\n"
"#define GET_NUM_GROUPS get_num_groups(0)\n"
"#define GROUP_LDS_BARRIER barrier(CLK_LOCAL_MEM_FENCE)\n"
"#define GROUP_MEM_FENCE mem_fence(CLK_LOCAL_MEM_FENCE)\n"
"#define AtomInc(x) atom_inc(&(x))\n"
"#define AtomInc1(x, out) out = atom_inc(&(x))\n"
"#define AppendInc(x, out) out = atomic_inc(x)\n"
"#define AtomAdd(x, value) atom_add(&(x), value)\n"
"#define AtomCmpxhg(x, cmp, value) atom_cmpxchg( &(x), cmp, value )\n"
"#define AtomXhg(x, value) atom_xchg ( &(x), value )\n"
"\n"
"#define max2 max\n"
"#define min2 min\n"
"\n"
"typedef unsigned int u32;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_worldPos[4];\n"
"	float4 m_worldNormal;	//	w: m_nPoints\n"
"//	float m_restituitionCoeff;\n"
"//	float m_frictionCoeff;\n"
"	u32 m_coeffs;\n"
"	u32 m_batchIdx;\n"
"//	int m_nPoints;\n"
"//	int m_padding0;\n"
"\n"
"	int m_bodyAPtrAndSignBit;//x:m_bodyAPtr, y:m_bodyBPtr\n"
"	int m_bodyBPtrAndSignBit;\n"
"} Contact4;\n"
"\n"
"#define GET_NPOINTS(x) (x).m_worldNormal.w\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_pos;\n"
"	float4 m_quat;\n"
"	float4 m_linVel;\n"
"	float4 m_angVel;\n"
"\n"
"	u32 m_shapeIdx;\n"
"	u32 m_shapeType;\n"
"	\n"
"	float m_invMass;\n"
"	float m_restituitionCoeff;\n"
"	float m_frictionCoeff;\n"
"} BodyData;\n"
"\n"
"\n"
"typedef struct  \n"
"{\n"
"	float4		m_localCenter;\n"
"	float4		m_extents;\n"
"	float4		mC;\n"
"	float4		mE;\n"
"	float			m_radius;\n"
"	\n"
"	int	m_faceOffset;\n"
"	int m_numFaces;\n"
"\n"
"	int	m_numVertices;\n"
"	int m_vertexOffset;\n"
"\n"
"	int	m_uniqueEdgesOffset;\n"
"	int	m_numUniqueEdges;\n"
"\n"
"} ConvexPolyhedronCL;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_plane;\n"
"	int m_indexOffset;\n"
"	int m_numIndices;\n"
"} btGpuFace;\n"
"\n"
"#define SELECT_UINT4( b, a, condition ) select( b,a,condition )\n"
"\n"
"#define make_float4 (float4)\n"
"#define make_float2 (float2)\n"
"#define make_uint4 (uint4)\n"
"#define make_int4 (int4)\n"
"#define make_uint2 (uint2)\n"
"#define make_int2 (int2)\n"
"\n"
"\n"
"__inline\n"
"float fastDiv(float numerator, float denominator)\n"
"{\n"
"	return native_divide(numerator, denominator);	\n"
"//	return numerator/denominator;	\n"
"}\n"
"\n"
"__inline\n"
"float4 fastDiv4(float4 numerator, float4 denominator)\n"
"{\n"
"	return native_divide(numerator, denominator);	\n"
"}\n"
"\n"
"\n"
"__inline\n"
"float4 cross3(float4 a, float4 b)\n"
"{\n"
"	return cross(a,b);\n"
"}\n"
"\n"
"__inline\n"
"float dot3F4(float4 a, float4 b)\n"
"{\n"
"	float4 a1 = make_float4(a.xyz,0.f);\n"
"	float4 b1 = make_float4(b.xyz,0.f);\n"
"	return dot(a1, b1);\n"
"}\n"
"\n"
"__inline\n"
"float4 fastNormalize4(float4 v)\n"
"{\n"
"	return fast_normalize(v);\n"
"}\n"
"\n"
"\n"
"///////////////////////////////////////\n"
"//	Quaternion\n"
"///////////////////////////////////////\n"
"\n"
"typedef float4 Quaternion;\n"
"\n"
"__inline\n"
"Quaternion qtMul(Quaternion a, Quaternion b);\n"
"\n"
"__inline\n"
"Quaternion qtNormalize(Quaternion in);\n"
"\n"
"__inline\n"
"float4 qtRotate(Quaternion q, float4 vec);\n"
"\n"
"__inline\n"
"Quaternion qtInvert(Quaternion q);\n"
"\n"
"\n"
"\n"
"\n"
"__inline\n"
"Quaternion qtMul(Quaternion a, Quaternion b)\n"
"{\n"
"	Quaternion ans;\n"
"	ans = cross3( a, b );\n"
"	ans += a.w*b+b.w*a;\n"
"//	ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\n"
"	ans.w = a.w*b.w - dot3F4(a, b);\n"
"	return ans;\n"
"}\n"
"\n"
"__inline\n"
"Quaternion qtNormalize(Quaternion in)\n"
"{\n"
"	return fastNormalize4(in);\n"
"//	in /= length( in );\n"
"//	return in;\n"
"}\n"
"__inline\n"
"float4 qtRotate(Quaternion q, float4 vec)\n"
"{\n"
"	Quaternion qInv = qtInvert( q );\n"
"	float4 vcpy = vec;\n"
"	vcpy.w = 0.f;\n"
"	float4 out = qtMul(qtMul(q,vcpy),qInv);\n"
"	return out;\n"
"}\n"
"\n"
"__inline\n"
"Quaternion qtInvert(Quaternion q)\n"
"{\n"
"	return (Quaternion)(-q.xyz, q.w);\n"
"}\n"
"\n"
"__inline\n"
"float4 qtInvRotate(const Quaternion q, float4 vec)\n"
"{\n"
"	return qtRotate( qtInvert( q ), vec );\n"
"}\n"
"\n"
"__inline\n"
"float4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\n"
"{\n"
"	return qtRotate( *orientation, *p ) + (*translation);\n"
"}\n"
"\n"
"\n"
"\n"
"__inline\n"
"float4 normalize3(const float4 a)\n"
"{\n"
"	float4 n = make_float4(a.x, a.y, a.z, 0.f);\n"
"	return fastNormalize4( n );\n"
"}\n"
"\n"
"\n"
"__inline float4 lerp3(const float4 a,const float4 b, float  t)\n"
"{\n"
"	return make_float4(	a.x + (b.x - a.x) * t,\n"
"						a.y + (b.y - a.y) * t,\n"
"						a.z + (b.z - a.z) * t,\n"
"						0.f);\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// Clips a face to the back of a plane, return the number of vertices out, stored in ppVtxOut\n"
"int clipFace(const float4* pVtxIn, int numVertsIn, float4 planeNormalWS,float planeEqWS, float4* ppVtxOut)\n"
"{\n"
"	\n"
"	int ve;\n"
"	float ds, de;\n"
"	int numVertsOut = 0;\n"
"//double-check next test\n"
"	if (numVertsIn < 2)\n"
"		return 0;\n"
"\n"
"	float4 firstVertex=pVtxIn[numVertsIn-1];\n"
"	float4 endVertex = pVtxIn[0];\n"
"	\n"
"	ds = dot3F4(planeNormalWS,firstVertex)+planeEqWS;\n"
"\n"
"	for (ve = 0; ve < numVertsIn; ve++)\n"
"	{\n"
"		endVertex=pVtxIn[ve];\n"
"\n"
"		de = dot3F4(planeNormalWS,endVertex)+planeEqWS;\n"
"\n"
"		if (ds<0)\n"
"		{\n"
"			if (de<0)\n"
"			{\n"
"				// Start < 0, end < 0, so output endVertex\n"
"				ppVtxOut[numVertsOut++] = endVertex;\n"
"			}\n"
"			else\n"
"			{\n"
"				// Start < 0, end >= 0, so output intersection\n"
"				ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\n"
"			}\n"
"		}\n"
"		else\n"
"		{\n"
"			if (de<0)\n"
"			{\n"
"				// Start >= 0, end < 0 so output intersection and end\n"
"				ppVtxOut[numVertsOut++] = lerp3(firstVertex, endVertex,(ds * 1.f/(ds - de)) );\n"
"				ppVtxOut[numVertsOut++] = endVertex;\n"
"			}\n"
"		}\n"
"		firstVertex = endVertex;\n"
"		ds = de;\n"
"	}\n"
"	return numVertsOut;\n"
"}\n"
"\n"
"\n"
"int clipFaceAgainstHull(const float4 separatingNormal, __global const ConvexPolyhedronCL* hullA,  \n"
"	const float4 posA, const Quaternion ornA, float4* worldVertsB1, int numWorldVertsB1,\n"
"	float4* worldVertsB2, int capacityWorldVertsB2,\n"
"	const float minDist, float maxDist,\n"
"	__global const float4* vertices,\n"
"	__global const btGpuFace* faces,\n"
"	__global const int* indices,\n"
"	float4* contactsOut,\n"
"	int contactCapacity)\n"
"{\n"
"	int numContactsOut = 0;\n"
"\n"
"	float4* pVtxIn = worldVertsB1;\n"
"	float4* pVtxOut = worldVertsB2;\n"
"	\n"
"	int numVertsIn = numWorldVertsB1;\n"
"	int numVertsOut = 0;\n"
"\n"
"	int closestFaceA=-1;\n"
"	{\n"
"		float dmin = FLT_MAX;\n"
"		for(int face=0;face<hullA->m_numFaces;face++)\n"
"		{\n"
"			const float4 Normal = make_float4(\n"
"				faces[hullA->m_faceOffset+face].m_plane.x, \n"
"				faces[hullA->m_faceOffset+face].m_plane.y, \n"
"				faces[hullA->m_faceOffset+face].m_plane.z,0.f);\n"
"			const float4 faceANormalWS = qtRotate(ornA,Normal);\n"
"		\n"
"			float d = dot3F4(faceANormalWS,separatingNormal);\n"
"			if (d < dmin)\n"
"			{\n"
"				dmin = d;\n"
"				closestFaceA = face;\n"
"			}\n"
"		}\n"
"	}\n"
"	if (closestFaceA<0)\n"
"		return numContactsOut;\n"
"\n"
"	btGpuFace polyA = faces[hullA->m_faceOffset+closestFaceA];\n"
"\n"
"	// clip polygon to back of planes of all faces of hull A that are adjacent to witness face\n"
"	int numVerticesA = polyA.m_numIndices;\n"
"	for(int e0=0;e0<numVerticesA;e0++)\n"
"	{\n"
"		const float4 a = vertices[hullA->m_vertexOffset+indices[polyA.m_indexOffset+e0]];\n"
"		const float4 b = vertices[hullA->m_vertexOffset+indices[polyA.m_indexOffset+((e0+1)%numVerticesA)]];\n"
"		const float4 edge0 = a - b;\n"
"		const float4 WorldEdge0 = qtRotate(ornA,edge0);\n"
"		float4 planeNormalA = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\n"
"		float4 worldPlaneAnormal1 = qtRotate(ornA,planeNormalA);\n"
"\n"
"		float4 planeNormalWS1 = -cross3(WorldEdge0,worldPlaneAnormal1);\n"
"		float4 worldA1 = transform(&a,&posA,&ornA);\n"
"		float planeEqWS1 = -dot3F4(worldA1,planeNormalWS1);\n"
"		\n"
"		float4 planeNormalWS = planeNormalWS1;\n"
"		float planeEqWS=planeEqWS1;\n"
"		\n"
"		//clip face\n"
"		//clipFace(*pVtxIn, *pVtxOut,planeNormalWS,planeEqWS);\n"
"		numVertsOut = clipFace(pVtxIn, numVertsIn, planeNormalWS,planeEqWS, pVtxOut);\n"
"\n"
"		//btSwap(pVtxIn,pVtxOut);\n"
"		float4* tmp = pVtxOut;\n"
"		pVtxOut = pVtxIn;\n"
"		pVtxIn = tmp;\n"
"		numVertsIn = numVertsOut;\n"
"		numVertsOut = 0;\n"
"	}\n"
"\n"
"	\n"
"	// only keep points that are behind the witness face\n"
"	{\n"
"		float4 localPlaneNormal  = make_float4(polyA.m_plane.x,polyA.m_plane.y,polyA.m_plane.z,0.f);\n"
"		float localPlaneEq = polyA.m_plane.w;\n"
"		float4 planeNormalWS = qtRotate(ornA,localPlaneNormal);\n"
"		float planeEqWS=localPlaneEq-dot3F4(planeNormalWS,posA);\n"
"		for (int i=0;i<numVertsIn;i++)\n"
"		{\n"
"			float depth = dot3F4(planeNormalWS,pVtxIn[i])+planeEqWS;\n"
"			if (depth <=minDist)\n"
"			{\n"
"				depth = minDist;\n"
"			}\n"
"\n"
"			if (depth <=maxDist)\n"
"			{\n"
"				float4 pointInWorld = pVtxIn[i];\n"
"				//resultOut.addContactPoint(separatingNormal,point,depth);\n"
"				contactsOut[numContactsOut++] = make_float4(pointInWorld.x,pointInWorld.y,pointInWorld.z,depth);\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	return numContactsOut;\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"int	clipHullAgainstHull(const float4 separatingNormal,\n"
"	__global const ConvexPolyhedronCL* hullA, __global const ConvexPolyhedronCL* hullB, \n"
"	const float4 posA, const Quaternion ornA,const float4 posB, const Quaternion ornB, \n"
"	float4* worldVertsB1, float4* worldVertsB2, int capacityWorldVerts,\n"
"	const float minDist, float maxDist,\n"
"	__global const float4* vertices,\n"
"	__global const btGpuFace* faces,\n"
"	__global const int* indices,\n"
"	float4*	localContactsOut,\n"
"	int localContactCapacity)\n"
"{\n"
"	int numContactsOut = 0;\n"
"	int numWorldVertsB1= 0;\n"
"\n"
"\n"
"	int closestFaceB=-1;\n"
"	float dmax = -FLT_MAX;\n"
"\n"
"	{\n"
"		for(int face=0;face<hullB->m_numFaces;face++)\n"
"		{\n"
"			const float4 Normal = make_float4(faces[hullB->m_faceOffset+face].m_plane.x, \n"
"				faces[hullB->m_faceOffset+face].m_plane.y, faces[hullB->m_faceOffset+face].m_plane.z,0.f);\n"
"			const float4 WorldNormal = qtRotate(ornB, Normal);\n"
"			float d = dot3F4(WorldNormal,separatingNormal);\n"
"			if (d > dmax)\n"
"			{\n"
"				dmax = d;\n"
"				closestFaceB = face;\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	{\n"
"		const btGpuFace polyB = faces[hullB->m_faceOffset+closestFaceB];\n"
"		const int numVertices = polyB.m_numIndices;\n"
"		for(int e0=0;e0<numVertices;e0++)\n"
"		{\n"
"			const float4 b = vertices[hullB->m_vertexOffset+indices[polyB.m_indexOffset+e0]];\n"
"			worldVertsB1[numWorldVertsB1++] = transform(&b,&posB,&ornB);\n"
"		}\n"
"	}\n"
"\n"
"	if (closestFaceB>=0)\n"
"	{\n"
"		numContactsOut = clipFaceAgainstHull(separatingNormal, hullA, \n"
"				posA,ornA,\n"
"				worldVertsB1,numWorldVertsB1,worldVertsB2,capacityWorldVerts, minDist, maxDist,vertices,\n"
"				faces,\n"
"				indices,localContactsOut,localContactCapacity);\n"
"	}\n"
"\n"
"	return numContactsOut;\n"
"}\n"
"\n"
"\n"
"\n"
"#define PARALLEL_SUM(v, n) for(int j=1; j<n; j++) v[0] += v[j];\n"
"#define PARALLEL_DO(execution, n) for(int ie=0; ie<n; ie++){execution;}\n"
"#define REDUCE_MAX(v, n) {int i=0;"
"	for(int offset=0; offset<n; offset++) v[i] = (v[i].y > v[i+offset].y)? v[i]: v[i+offset]; }\n"
"#define REDUCE_MIN(v, n) {int i=0;"
"	for(int offset=0; offset<n; offset++) v[i] = (v[i].y < v[i+offset].y)? v[i]: v[i+offset]; }\n"
"\n"
"int extractManifoldSequential(const float4* p, int nPoints, float4 nearNormal, int* contactIdx)\n"
"{\n"
"	if( nPoints == 0 ) return 0;\n"
"\n"
"	nPoints = min2( nPoints, 64 );\n"
"\n"
"	float4 center = make_float4(0.f);\n"
"	{\n"
"		float4 v[64];\n"
"		for (int i=0;i<nPoints;i++)\n"
"			v[i] = p[i];\n"
"		//memcpy( v, p, nPoints*sizeof(float4) );\n"
"		PARALLEL_SUM( v, nPoints );\n"
"		center = v[0]/(float)nPoints;\n"
"	}\n"
"\n"
"	\n"
"\n"
"	{	//	sample 4 directions\n"
"		if( nPoints < 4 )\n"
"		{\n"
"			for(int i=0; i<nPoints; i++) \n"
"				contactIdx[i] = i;\n"
"			return nPoints;\n"
"		}\n"
"\n"
"		float4 aVector = p[0] - center;\n"
"		float4 u = cross3( nearNormal, aVector );\n"
"		float4 v = cross3( nearNormal, u );\n"
"		u = normalize3( u );\n"
"		v = normalize3( v );\n"
"\n"
"		int idx[4];\n"
"\n"
"		float2 max00 = make_float2(0,FLT_MAX);\n"
"		{\n"
"			//	idx, distance\n"
"			{\n"
"				{\n"
"					int4 a[64];\n"
"					for(int ie = 0; ie<nPoints; ie++ )\n"
"					{\n"
"						\n"
"						\n"
"						float f;\n"
"						float4 r = p[ie]-center;\n"
"						f = dot3F4( u, r );\n"
"						a[ie].x = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\n"
"\n"
"						f = dot3F4( -u, r );\n"
"						a[ie].y = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\n"
"\n"
"						f = dot3F4( v, r );\n"
"						a[ie].z = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\n"
"\n"
"						f = dot3F4( -v, r );\n"
"						a[ie].w = ((*(u32*)&f) & 0xffffff00) | (0xff & ie);\n"
"					}\n"
"\n"
"					for(int ie=0; ie<nPoints; ie++)\n"
"					{\n"
"						a[0].x = (a[0].x > a[ie].x )? a[0].x: a[ie].x;\n"
"						a[0].y = (a[0].y > a[ie].y )? a[0].y: a[ie].y;\n"
"						a[0].z = (a[0].z > a[ie].z )? a[0].z: a[ie].z;\n"
"						a[0].w = (a[0].w > a[ie].w )? a[0].w: a[ie].w;\n"
"					}\n"
"\n"
"					idx[0] = (int)a[0].x & 0xff;\n"
"					idx[1] = (int)a[0].y & 0xff;\n"
"					idx[2] = (int)a[0].z & 0xff;\n"
"					idx[3] = (int)a[0].w & 0xff;\n"
"				}\n"
"			}\n"
"\n"
"			{\n"
"				float2 h[64];\n"
"				PARALLEL_DO( h[ie] = make_float2((float)ie, p[ie].w), nPoints );\n"
"				REDUCE_MIN( h, nPoints );\n"
"				max00 = h[0];\n"
"			}\n"
"		}\n"
"\n"
"		contactIdx[0] = idx[0];\n"
"		contactIdx[1] = idx[1];\n"
"		contactIdx[2] = idx[2];\n"
"		contactIdx[3] = idx[3];\n"
"\n"
"//		if( max00.y < 0.0f )\n"
"//			contactIdx[0] = (int)max00.x;\n"
"\n"
"		//does this sort happen on GPU too?\n"
"		//std::sort( contactIdx, contactIdx+4 );\n"
"\n"
"		return 4;\n"
"	}\n"
"}\n"
"\n"
"\n"
"\n"
"__kernel void   extractManifoldAndAddContactKernel(__global const int2* pairs, \n"
"																	__global const BodyData* rigidBodies, \n"
"																	__global const float4* closestPointsWorld,\n"
"																	__global const float4* separatingNormalsWorld,\n"
"																	__global const int* contactCounts,\n"
"																	__global const int* contactOffsets,\n"
"																	__global Contact4* restrict contactsOut,\n"
"																	counter32_t nContactsOut,\n"
"																	int numPairs,\n"
"																	int pairIndex\n"
"																	)\n"
"{\n"
"	int idx = get_global_id(0);\n"
"	\n"
"	if (idx<numPairs)\n"
"	{\n"
"		float4 normal = separatingNormalsWorld[idx];\n"
"		int nPoints = contactCounts[idx];\n"
"		__global const float4* pointsIn = &closestPointsWorld[contactOffsets[idx]];\n"
"		float4 localPoints[64];\n"
"		for (int i=0;i<nPoints;i++)\n"
"		{\n"
"			localPoints[i] = pointsIn[i];\n"
"		}\n"
"		int contactIdx[4] = {-1,-1,-1,-1};\n"
"\n"
"		int nContacts = extractManifoldSequential(localPoints, nPoints, normal, contactIdx);\n"
"\n"
"		int dstIdx;\n"
"		AppendInc( nContactsOut, dstIdx );\n"
"		//if ((dstIdx+nContacts) < capacity)\n"
"		{\n"
"			__global Contact4* c = contactsOut + dstIdx;\n"
"			c->m_worldNormal = normal;\n"
"			c->m_coeffs = (u32)(0.f*0xffff) | ((u32)(0.7f*0xffff)<<16);\n"
"			c->m_batchIdx = idx;\n"
"			int bodyA = pairs[pairIndex].x;\n"
"			int bodyB = pairs[pairIndex].y;\n"
"			c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0 ? -bodyA:bodyA;\n"
"			c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0 ? -bodyB:bodyB;\n"
"			for (int i=0;i<nContacts;i++)\n"
"			{\n"
"				c->m_worldPos[i] = localPoints[contactIdx[i]];\n"
"			}\n"
"			GET_NPOINTS(*c) = nContacts;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"\n"
"__kernel void   clipHullHullKernel( __global const int2* pairs, \n"
"																					__global const BodyData* rigidBodies, \n"
"																					__global const ConvexPolyhedronCL* convexShapes, \n"
"																					__global const float4* vertices,\n"
"																					__global const float4* uniqueEdges,\n"
"																					__global const btGpuFace* faces,\n"
"																					__global const int* indices,\n"
"																					__global const float4* separatingNormals,\n"
"																					__global const int* hasSeparatingAxis,\n"
"																					__global Contact4* restrict globalContactsOut,\n"
"																					counter32_t nGlobalContactsOut,\n"
"																					int numPairs)\n"
"{\n"
"\n"
"	int i = get_global_id(0);\n"
"	int pairIndex = i;\n"
"	\n"
"	float4 worldVertsB1[64];\n"
"	float4 worldVertsB2[64];\n"
"	int capacityWorldVerts = 64;	\n"
"\n"
"	float4 localContactsOut[64];\n"
"	int localContactCapacity=64;\n"
"	\n"
"	float minDist = -1e30f;\n"
"	float maxDist = 0.02f;\n"
"\n"
"	if (i<numPairs)\n"
"	{\n"
"\n"
"		if (hasSeparatingAxis[i])\n"
"		{\n"
"\n"
"			int bodyIndexA = pairs[i].x;\n"
"			int bodyIndexB = pairs[i].y;\n"
"			int shapeIndexA = rigidBodies[bodyIndexA].m_shapeIdx;\n"
"			int shapeIndexB = rigidBodies[bodyIndexB].m_shapeIdx;\n"
"\n"
"		\n"
"			int numLocalContactsOut = clipHullAgainstHull(separatingNormals[i],\n"
"														&convexShapes[shapeIndexA], &convexShapes[shapeIndexB],\n"
"														rigidBodies[bodyIndexA].m_pos,rigidBodies[bodyIndexA].m_quat,\n"
"													  rigidBodies[bodyIndexB].m_pos,rigidBodies[bodyIndexB].m_quat,\n"
"													  worldVertsB1,worldVertsB2,capacityWorldVerts,\n"
"														minDist, maxDist,\n"
"														vertices,faces,indices,\n"
"														localContactsOut,localContactCapacity);\n"
"												\n"
"		if (numLocalContactsOut>0)\n"
"		{\n"
"				float4 normal = -separatingNormals[i];\n"
"				int nPoints = numLocalContactsOut;\n"
"				float4* pointsIn = localContactsOut;\n"
"				int contactIdx[4] = {-1,-1,-1,-1};\n"
"		\n"
"				int nReducedContacts = extractManifoldSequential(pointsIn, nPoints, normal, contactIdx);\n"
"		\n"
"				int dstIdx;\n"
"				AppendInc( nGlobalContactsOut, dstIdx );\n"
"				//if ((dstIdx+nReducedContacts) < capacity)\n"
"				{\n"
"					__global Contact4* c = globalContactsOut+ dstIdx;\n"
"					c->m_worldNormal = normal;\n"
"					c->m_coeffs = (u32)(0.f*0xffff) | ((u32)(0.7f*0xffff)<<16);\n"
"					c->m_batchIdx = pairIndex;\n"
"					int bodyA = pairs[pairIndex].x;\n"
"					int bodyB = pairs[pairIndex].y;\n"
"					c->m_bodyAPtrAndSignBit = rigidBodies[bodyA].m_invMass==0?-bodyA:bodyA;\n"
"					c->m_bodyBPtrAndSignBit = rigidBodies[bodyB].m_invMass==0?-bodyB:bodyB;\n"
"\n"
"					for (int i=0;i<nReducedContacts;i++)\n"
"					{\n"
"						c->m_worldPos[i] = pointsIn[contactIdx[i]];\n"
"					}\n"
"					GET_NPOINTS(*c) = nReducedContacts;\n"
"				}\n"
"				\n"
"			}//		if (numContactsOut>0)\n"
"		}//		if (hasSeparatingAxis[i])\n"
"	}//	if (i<numPairs)\n"
"\n"
"}\n"
;
